\documentclass{article}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{amsmath}
\newcommand{\py}[1]{\texttt{#1}}
\begin{document}

\begin{algorithm}
\caption{PlayStep}
\label{alg:your_algorithm}
\begin{algorithmic}[1]
%%%%%%%%%%%%%%%
\State Input \py{t\_inf}, \py{c\_scr}, \py{t\_snw}, \py{t\_sid}
\hfill \textcolor{green!50!black}{\scriptsize \# input tensors}
\Statex \textcolor{green!50!black}{\scriptsize \# \py{t\_inf.shape}$=[d_0,3,d_2]$, 
\py{c\_scr}$= [s_1,\cdots,s_{d_0}]$,  \py{t\_snw.shape}$=[d_0,8]$}
\Statex \textcolor{green!50!black}{\scriptsize \# $v_k:= \left\vert V_k\right\vert = s_1+\cdots+s_{d_0}$, \py{t\_sid.shape}$=[v_k,2]$}
\Statex \textcolor{green!50!black}{\scriptsize \# $[i,j] \in $ \py{t\_sid} \textit{i.e.,} \py{t\_scr[j]} $\in \mathcal{H}(\py{t\_inf[i]})$} 
%%%%%%%%%%%%%%%
\vspace{0.5em}
\State \py{t\_act,c\_act = find\_moves(t\_inf)} \hfill \textcolor{green!50!black}{\scriptsize \# find available moves}
\Statex \textcolor{green!50!black}{\scriptsize \# \py{c\_act} $= [a_1,\cdots,a_{d_0}]$, \py{t\_act.shape} $= [\tilde{d}_0,3,d_2]$}
\Statex \textcolor{green!50!black}{\scriptsize \# $\tilde{d}_0 = a_1+\cdots+a_{d_0}$}\Statex\textcolor{green!50!black}{\scriptsize\#$v_{k+1} = \left\vert V_{k+1}\right\vert =s_1a_1+\cdots+s_{d_0}a_{d_0}$}
%%%%%%%%%%%%%%%
\vspace{0.5em}
\State $\py{t\_inf} \gets \py{t\_inf} \otimes \py{c\_act}$ \hfill \textcolor{green!50!black}{\scriptsize \# \py{t\_inf.shape}$=[\tilde{d}_0,3,d_2]$}
% \State $\py{t\_snw} \gets \py{t\_snw} \otimes \py{c\_act}$ \hfill \textcolor{green!50!black}{\scriptsize \# \py{t\_snw.shape}$=[\tilde{d}_0,8]$}
\State \py{t\_inf}, \py{t\_snw} $\gets \py{apply\_moves}(\py{t\_inf}, \py{t\_act}, \py{t\_snw})$
\Statex \textcolor{green!50!black}{\scriptsize \# \py{t\_inf} retains shape. \py{t\_snw.shape}$=[\tilde{d}_0,8]$}
\State \py{t\_cl1} $\gets$ \py{t\_sid[:,1]}$\otimes_{\tiny\py{c\_scr}}$\py{c\_act}
\hfill 
\textcolor{green!50!black}{\scriptsize\# See Section \ref{sec:RepeatBlocks}}
\State \py{t\_edg} $\gets$ \py{arange(i\_sid)}$\otimes_{\py{c\_scr}}$\py{c\_act}
\hfill \textcolor{green!50!black}{\scriptsize\# \py{i\_sid=sum(c\_scr)}}
% \State \py{c\_tot} $\gets$ \py{c\_scr$\times$c\_act}
% \State \py{t\_sft} $\gets$ \py{cumsum(cat([0,c\_tot[:-1]))}
% \hfill \textcolor{green!50!black}{\scriptsize\# \py{t\_sft}$=[0,s_1a_1,s_1a_1+s_2a_2,\cdots]$}
\State \py{c\_scr} $\gets$ \py{c\_scr$\otimes$c\_act}
\hfill \textcolor{green!50!black}{\scriptsize\# \py{c\_scr}$=[s_1,\cdots,s_1,\cdots,s_{d_0},\cdots,s_{d_0}]$}
\State \py{t\_cl0} $\gets$ \py{arange}(\py{i\_inf})$\otimes$\py{c\_scr}
\State \py{t\_sid} $\gets$ \py{cat([t\_cl0,t\_cl1])}  \hfill \textcolor{green!50!black}{\scriptsize \#\py{t\_sid.shape}$=[v_{k+1},2]$}
% \State \py{t\_edg} $\gets$ \py{t\_col1}+\py{t\_sft}$\otimes$\py{t\_tot}
% \py{t\_edg} = \py{arange(c\_act.sum())} \otimes_{\py{c\_scr}} \py{c\_act}
% \Statex\textcolor{green!50!black}{\scriptsize\#\py{t\_edge} connects $V_k$ to $V_{k+1}$. See Algorithm 2.}
% \vspace{0.5em}
\State Output \py{t\_inf, c\_scr, t\_snw, t\_sid, t\_edg}
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{StrategyEvalStep}
\label{alg:your_algorithm}
\begin{algorithmic}[1]
%%%%%%%%%%%%%%%
\Statex\textcolor{green!50!black}{\scriptsize \#\py{The strategy profile at the current information set is evaluated using the neural network V\_pnn. The input to this network, denoted by t\_nn, consists of two components: t\_nnl and t\_nnr.}}
\State Input \py{t\_inf,t\_scr,c\_scr,t\_sid,t\_edg,V\_pnn} 
\Statex \textcolor{green!50!black}{\scriptsize \# \py{t\_inf.shape}$=[\tilde{d}_0,3,d_2]$}
\State \py{t\_sum} $\gets$ \py{zeros(v\_k)} \hfill \textcolor{green!50!black}{\scriptsize\# \py{t\_sid.shape[0]$=v_k$}}
% \State \py{t\_inf, \_ , \_ , t\_sid, t\_edg}$\gets$\py{PlayStep(t\_inf, c\_scr, t\_snw, t\_sid)}
\State \py{t\_nnl} $\gets$ \py{t\_inf}$\otimes$\py{c\_scr}\hfill \textcolor{green!50!black}{\scriptsize\# \py{t\_nnl.shape=$[v_{k+1},3,d_2]$ }}
\State \py{t\_nnr} $\gets$ \py{t\_scr[t\_sid[:,1]]}
\State \py{t\_reg} $\gets$ \py{V\_pnn(cat([t\_nnl,t\_nnr]))}
\State \py{t\_sum.scatter\_add\_(0,t\_edg,t\_reg)}
\State \py{t\_sig} $\gets$ \py{t\_reg/t\_sum[t\_edge]}
\State Output \py{t\_sig,t\_reg}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{SimulateGameRun}
\label{alg:your_algorithm}
\begin{algorithmic}[1]
\State Initialize \py{t\_dck,t\_inf,t\_sid,t\_scr,t\_m52,t\_mdd, V\_ann,V\_bnn,M\_snn}

\Statex \textcolor{green!50!black}{\scriptsize\# 
$\gets$ \py{random deck, zeros(1,3,4), zeros(1,2), zeros(1,4), zerbo(52), zerbo(52),3*zeros nn }}
\State \py{t\_m52[t\_dck[:4]] $\gets$ True}, \py{t\_inf[0,0,:] = 3, t\_dck = t\_dck[4:]}
\Statex \textcolor{green!50!black}{\scriptsize\#
\py{deal pool cards}}
\vspace{0.2em}
\State\py{for i\_rnd in range(6):}
\vspace{0.5em}
\State \hspace*{1em}\py{t\_inf, t\_dck,t\_m52,t\_mdd $\gets$ DealandUpdate()}
\Statex \hspace*{1em}\textcolor{green!50!black}{\scriptsize\# \py{DealandUpdate(t\_dck,t\_inf,t\_m52,t\_mdd)}}
\vspace{0.2em}
\State \hspace*{1em}\py{c\_snw $\gets$ zeros(i\_inf,8), c\_scr $\gets$ v\_count(t\_sid[:,0])}
\vspace{0.2em}
\State \hspace*{1em}\py{for i\_trn in range(4):}
\State \hspace*{2em}\py{for i\_ply in range(2):}
\vspace{0.5em}
\Statex \hspace*{3em}\textcolor{green!50!black}{\scriptsize\# \py{update c\_scr after StrategyEvalStep}}
\State \hspace*{3em}\py{t\_inf,$\hat{\py{c}}$\_scr,t\_snw,t\_sid,t\_edg} $\gets$\py{PlayStep()}
\Statex \hspace*{3em}\textcolor{green!50!black}{\scriptsize\# \py{PlayStep(t\_inf,c\_scr,t\_snw,t\_sid)}}
\State \hspace*{3em}\py{t\_sig,t\_reg} $\gets$ \py{StrategyEvalStep()}
\Statex \hspace*{3em}\textcolor{green!50!black}{\scriptsize\#\py{t\_inf[:,0,:][t\_inf[:,0,:]==i\_ply+1] = 0 \# hide info. NB: t\_inf from disk}}
\Statex \hspace*{3em}\textcolor{green!50!black}{\scriptsize\#\py{StrategyEvalStep(t\_inf, t\_scr, c\_scr, t\_sid, t\_edg, V\_pnn)}}
\State \hspace*{3em}\py{c\_scr} $\gets$ \py{$\hat{\py{c}}$\_scr}
\vspace{0.2em}
\State \hspace*{1em}\py{if i\_rnd == 5: t\_snw $\gets$ CleanUpPool()}
\Statex \hspace*{1em}\textcolor{green!50!black}{\scriptsize\#\py{CleanUpPool(t\_inf,t\_snw)}}
\State  \hspace*{1em}\py{t\_inf,t\_scr,c\_scr,t\_sid,t\_edg $\gets$ ProcessStep()}

\end{algorithmic}
\end{algorithm}


\end{document}

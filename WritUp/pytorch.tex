In this section, we present our framework for implementing the CFR algorithm for \emph{Pasur} using PyTorch. We begin by describing how the game tree is generated and recorded using tensor operations. The game consists of 5 rounds, and in each round, both players take 4 turns. Therefore, the full game comprises 40 steps, giving rise to a game tree of depth 40.

During the tree construction process, we distinguish between the \emph{card state}—including the cards held by Alex, the cards held by Bob, and the cards in the pool—and the \emph{score information}, which is updated independently. A given card state may correspond to multiple incoming edges, each representing a different score inherited from earlier rounds. Figure~\ref{fig:gametreegeneration} illustrates this structural design.


Alongside the Game Tree illustrated in Figure~\ref{fig:gametreegeneration}, we construct a \emph{Full Game Tree} via an \emph{unfolding process}, which systematically expands the tree by combining each card state with all compatible incoming scores.

\begin{center}
\textit{To ensure memory efficiency, the only parameters stored for the Full Game Tree are the strategy values at each node and the edges linking nodes between successive layers.}
\end{center}

Each node in the Full Game Tree is thus represented as a pair: a Game Tree node and its corresponding incoming score. We also explicitly maintain the edge structure between nodes, which is crucial for updating strategies during the CFR iterations. Figure~\ref{fig:tedge} provides a visual representation of the unfolding process. Further details on this mechanism and the edge-tracking procedure are discussed in the subsections that follow.


Table~\ref{table:tensors} summarizes the key components involved in our framework.  Before proceeding to the next section, we first describe how a set of cards is represented as a PyTorch tensor. As illustrated in Figure~\ref{fig:deck}, each card is mapped to a unique tensor index according to a fixed, natural order. The interpretation of the tensor values at these positions varies depending on the specific tensor in which they appear: it may indicate card ownership (e.g., who holds the card) or an action involving that card (e.g., laid or picked), depending on whether the tensor encodes game state, actions, or other game-related structures. This indexing convention serves as the foundation for constructing all tensors listed in Table~\ref{table:tensors}.

\begin{figure}[h]
    \centering
\begin{tikzpicture}
    % Define grid dimensions
    \def\n{1} % N = 5 rows
    \def\m{20} % M = 5 columns
    \def\cellsize{0.7} % Size of each cell

    % Draw the grid
    \foreach \i in {0,...,\n} {
        \draw[lightgray] (0,\i*\cellsize) -- (\m*\cellsize,\i*\cellsize); % Horizontal lines
    }
    % \foreach \j in {0,...,\m} {
    %     \draw[lightgray] (\j*\cellsize,0) -- (\j*\cellsize,\n*\cellsize); % Vertical lines
    % }

    Place dots in the middle row (row 3, columns 2, 3, and 4)
    \foreach \j in {0,1,2} {
        \fill[black] ({(1-\j)/2+\m*\cellsize/2}, 0.5*\cellsize) circle (0.03); % Dots
    }

    \foreach \j in {0,...,\m} {
        \ifnum\j<7 % Check if j < 10
            \draw[lightgray] (\j*\cellsize,0) -- (\j*\cellsize,\n*\cellsize); % Draw line
        \else
            \ifnum\j>13 % Check if j > 20
                \draw[lightgray] (\j*\cellsize,0) -- (\j*\cellsize,\n*\cellsize); % Draw line
            \fi
        \fi
        }

    % Draw the outer rectangle
    \draw[black] (0,0) rectangle (\m*\cellsize, \n*\cellsize);

    % Add the shape label below the grid
    % \node[below] at ({\m/2*\cellsize}, 4.5*\cellsize) {\pyvar{t\_z[:,0,:]}};

    % \draw[->, thin, decorate, decoration={coil, segment length=7mm, amplitude=2mm}] 
    %     ({(\m-2)*\cellsize+0.1}, \n*\cellsize+0.1) -- ++(2,1) % Arrow starts at (5,5) and extends 2 units right
    %     node[above, right, align=left] {\small A card has \\ \;$\cdot$ a rank\\ \;$\cdot$ a suit}; % Text at the end of the arrow

    \node at (0.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\AC$};
    \node at (1.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\AD$};
    \node at (2.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\AH$};
    \node at (3.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\AS$};
    \node at (4.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\TwC$};
    \node at (5.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\TwD$};

    \node at (14.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\QH$};
    \node at (15.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\QS$};
    \node at (16.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\KC$};
    \node at (17.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\KD$};
    \node at (18.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\KH$};
    \node at (19.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\scriptsize $\KS$};

    
\end{tikzpicture}
\caption{Mapping Cards to Indices}
\label{fig:deck}
\end{figure}


To manage memory efficiently during game tree generation, we maintain two boolean tensors that track card availability throughout the game. Let \py{N} denote the number of \emph{in-play cards}—those currently in play, either held by a player or present in the pool. For instance, in the first round, \py{N = 12}, since each player is dealt four cards and four cards are placed in the pool. At the end of each round, we update the set of in-play cards: we remove any cards that have been picked across all nodes and add new cards that are about to be dealt. 

This information is captured using the \py{t\_inp} tensor. This binary tensor marks which cards are currently involved in the game—either held by players or present in the pool—and serves as the basis for constructing and updating all relevant tensors during game tree generation. It is emphasized that as a result of this, the shapes of certain tensors—particularly those that represent actions or action history, such as \py{t\_act} and \py{t\_gme}—may vary across rounds to reflect the current number of in-play cards. To illustrate this point, consider the following initial configuration of the game, shown in Table~\ref{table:deck9}. 
% \begin{itemize}
%     \item \py{t\_inp}: the \emph{In-Play Card Tensor}, which indicates the cards active in the current round;
%     \item \py{t\_out}: the \emph{Out-of-Play Card Tensor}, which marks cards that have been picked or discarded and are no longer in play.
% \end{itemize}
\begin{table}[h!]
\centering
\caption{Initial setup for a single game instance}
\label{table:deck9}
\begin{tabular}{lcccc}
\toprule
\textbf{Alex} & $\FoC$ & $\FoD$ & $\SeD$ & $\QC$ \\
\textbf{Bob} & $\ThD$ & $\ThH$ & $\FiC$ & $\KS$ \\
\textbf{Pool} & $\AC$ & $\AS$ & $\ND$ & $\KD$ \\
\bottomrule
\end{tabular}
\end{table}
\begin{figure}[h]
    \centering
\begin{tikzpicture}
    % Define grid dimensions
    \def\n{1} % N = 5 rows
    \def\m{25} % M = 5 columns
    \def\cellsize{0.6} % Size of each cell

    % Draw the grid
    \foreach \i in {0,...,\n} {
        \draw[lightgray] (0,\i*\cellsize) -- (\m*\cellsize,\i*\cellsize); % Horizontal lines
    }
    % \foreach \j in {0,...,\m} {
    %     \draw[lightgray] (\j*\cellsize,0) -- (\j*\cellsize,\n*\cellsize); % Vertical lines
    % }

    % Place dots in the middle row (row 3, columns 2, 3, and 4)
    \foreach \j in {0,1,2} {
        \fill[black] ({(1-\j)/2+\m*\cellsize/2+0.5}, 0.5*\cellsize) circle (0.03); % Dots
    }

    \foreach \j in {0,...,\m} {
        \ifnum\j<12 % Check if j < 10
            \draw[lightgray] (\j*\cellsize,0) -- (\j*\cellsize,\n*\cellsize); % Draw line
        \else
            \ifnum\j>15 % Check if j > 20
                \draw[lightgray] (\j*\cellsize,0) -- (\j*\cellsize,\n*\cellsize); % Draw line
            \fi
        \fi
        }

    % Draw the outer rectangle
    \draw[black] (0,0) rectangle (\m*\cellsize, \n*\cellsize);

    % Add the shape label below the grid
    % \node[below] at ({\m/2*\cellsize}, 4.5*\cellsize) {\pyvar{t\_z[:,0,:]}};

    % \draw[->, thin, decorate, decoration={coil, segment length=7mm, amplitude=2mm}] 
    %     ({(\m-2)*\cellsize+0.1}, \n*\cellsize+0.1) -- ++(2,1) % Arrow starts at (5,5) and extends 2 units right
    %     node[above, right, align=left] {\small A card has \\ \;$\cdot$ a rank\\ \;$\cdot$ a suit}; % Text at the end of the arrow

    \node at (0.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{True}};
    \node at (1.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (2.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (3.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{True}};
    \node at (4.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (5.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (6.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (7.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (8.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (9.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{True}};
    \node at (10.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny\py{True}};
    
    \node at (0.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\AC$};
    \node at (1.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\AD$};
    \node at (2.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\AH$};
    \node at (3.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\AS$};
    \node at (4.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\TwC$};
    \node at (5.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\TwD$};
    \node at (6.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\TwH$};
    \node at (7.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\TwS$};
    \node at (8.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\ThC$};
    \node at (9.5*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\ThD$};
    \node at (10.5*\cellsize,\n*\cellsize-1.4*\cellsize) {\tiny $\ThH$};

    \node at (16.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (17.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{True}};
    \node at (18.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (19.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (20.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (21.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (22.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{True}};
    \node at (23.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{False}};
    \node at (24.5*\cellsize, \n*\cellsize-0.4*\cellsize) {\tiny \py{True}};
    
    \node at (16.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\JS$};
    \node at (17.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\QC$};
    \node at (18.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\QD$};
    \node at (19.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\QH$};
    \node at (20.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\QS$};
    \node at (21.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\KC$};
    \node at (22.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\KD$};
    \node at (23.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\KH$};
    \node at (24.4*\cellsize, \n*\cellsize-1.4*\cellsize) {\tiny $\KS$};

    
\end{tikzpicture}
\caption{\py{t\_inp} tensor at the beginning of the game for the initial setup shown in Table~\ref{table:deck9}}
\label{fig:tinp_ex}
\end{figure}


\begin{table}[h!]
\centering
\scriptsize
\caption{Summary of Tensors Used in Game Tree Construction}
\label{tab:gametree_tensors_detailed}
\begin{tabular}{
>{\centering\arraybackslash}m{1.3cm}  % Component
>{\centering\arraybackslash}m{1.3cm}  % Tensor
>{\centering\arraybackslash}m{1cm}    % Shape
>{\centering\arraybackslash}m{1.3cm}  % Type
>{\centering\arraybackslash}m{2cm}    % Update
>{\raggedright\arraybackslash}p{5.5cm}% Description (left-aligned)
}
\toprule
\textbf{Component} & \textbf{Tensor} & \textbf{Shape} & \textbf{Type} & \textbf{Update} & \textbf{Description} \\
\midrule
Game & \py{t\_gme} & \py{[M,3,N]} & \py{int8} & Per turn & Encodes state and action history per node. Each slice represents a singleton node in the tree layer. \\
\midrule
In-Play Cards & \py{t\_inp} & \py{[52]} & \py{int8} & Per round & Boolean indicator for whether each of the 52 cards is still in play (held or in pool). \\
\midrule
Dealt Cards & \py{t\_dlt} & \py{[52]} & \py{int8} & Per round & Boolean indicator marking cards that have been dealt in previous rounds. \\
\midrule
Full Game & \py{t\_fgm} & \py{[Q, 2]} & \py{int32} & Per turn / round & Each row \py{[i, s]} in \py{t\_fgm} indicates that node \py{i} in the game tree \py{t\_gme} inherits the score with ID \py{s} from \py{t\_scr}. Here, \py{Q} denotes the number of nodes in the current layer of the Full Game Tree.
 \\
\midrule
Scores & \py{t\_scr} & \py{[S,4]} & \py{int8} & Per round & Unique score triples in the form (Alex clubs, Bob clubs, Point Difference). \\
\midrule
Action & \py{t\_act} & \py{[M',2,N]} & \py{int8} & Per turn & Action representation per node. \py{[0,:]} encodes the lay card; \py{[1,:]} encodes picked cards. Here, \py{M'} denotes the number of nodes in the next layer of the Game Tree. \\
\midrule
Branch Factor & \py{t\_brf} & \py{[M]} & \py{int8} & Per turn & Number of valid actions available from each node; used to replicate game states before applying actions. \\
\midrule
Linkage & \py{t\_lnk} & \py{[M,2]} & \py{int8} & Per round & Connects nodes between consecutive hands to identify how scores and states map across hands. Used during in-between-hand updates. \\
\midrule
Edge & \py{t\_edg} & \py{[Q',2]} & \py{int32} & Per turn & Records edges between nodes in the full game tree to track the structure of the overall graph. Here, \py{Q'} denotes the number of nodes in the next layer of the Full Game Tree. \\
\midrule
Strategy & \py{t\_sgm} & \py{[Q]} & \py{float32} & Per turn & Stores the strategy values (e.g., probabilities) associated with each node in the Full Game Tree. \\
\midrule
Infoset & \py{t\_inf} & \py{[Q,58]} & \py{int8} & Per turn & Encodes information available to the player whose turn it is. \py{t\_inf} hides information that is not observable by the acting player. It also includes metadata such as round index, turn counter, and cumulative score up to the previous round. \\
\bottomrule
\end{tabular}
\label{table:tensors}
\end{table}

\begin{figure}[!p]
\centering
\scalebox{0.5}{
    \begin{tikzpicture}

       %%% DECK COUNT 40 LAYER 0
      \drawboxwitharrows{0}{red/0.2}{dummy}{0}{2cm,0cm}{none}
      %%% DECK COUNT 40 LAYER 1
      \drawboxwitharrows{0}{red/0.2}{dummy}{0}{0cm, -2cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{1}{1cm, -2cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{2}{2cm, -2cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{3}{3cm, -2cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{4}{4cm, -2cm}{none}
      \draw (-0.5cm, -2.5cm) -- (4.5cm, -2.5cm);

        %%% DOTS
      \node[rotate=60] at  (0.5cm, -3.2cm) {\dots\dots};    
      \node[rotate=90] at (2cm, -3.2cm) {\dots\dots};        
      \node[rotate=-60] at (3.5cm, -3.2cm) {\dots\dots};      

      
      %%% DECK COUNT 40 LAYER END
      \drawboxwitharrows{0}{red/0.2}{dummy}{0}{-2cm, -5cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{1}{-1cm, -5cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{2}{0cm, -5cm} {none}
      \node[rotate=0] at  (2cm, -5cm) {\dots\dots};
      \drawboxwitharrows{0}{red/0.2}{dummy}{-3}{4cm,  -5cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{-2}{5cm,  -5cm}{none}
      \drawboxwitharrows{0}{red/0.2}{dummy}{-1}{6cm,  -5cm}{none}
        \draw (-2.5cm, -5.5cm) -- (-0.5cm, -5.5cm);
        \draw (-0.3cm, -5.5cm) -- (0.4cm, -5.5cm);
        \draw (3.5cm, -5.5cm) -- (5.5cm, -5.5cm);
        \draw (5.7cm, -5.5cm) -- (6.4cm, -5.5cm);


         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-2, -5.3) to[out=-80, in=60] (0, -7.75); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (4, -5.3) to[out=-80, in=60] (-1, -7.75); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-1, -5.3) to[out=-80, in=120] (5, -7.75); 
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (0, -5.3) to[out=-80, in=60] (-1, -7.75); 
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (5, -5.3) to[out=-80, in=60] (0, -7.75); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (6, -5.3) to[out=-80, in=60] (5, -7.75); 
        
        %%% DECK COUNT 32 LAYER 0
      \drawboxwitharrows{0}{}{dummy}{0}  {-1cm,  -8cm}{none}
      \drawboxwitharrows{0}{}{dummy}{1}  {0cm,   -8cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, red/0.05}{dummy}{2}  {1cm,   -8cm}   {none}
      \drawboxwitharrows{0}{blue!50/0.4, black/0.05}{dummy}{3}  {2cm,   -8cm} {none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}{4}  {3cm,   -8cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, green/0.05}{dummy}{5}  {4cm,   -8cm} {none}
      \drawboxwitharrows{0}{}{dummy}{6}  {5cm,   -8cm}{none}

       %%% DECK COUNT 32 LAYER 1
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {0}    {-4cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {1}    {-3cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4}{dummy}                                       {2}    {-2cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4}{dummy}                                       {3}    {-1cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4}{dummy}                                       {4}    {0cm,   -10cm}{none}
      \node[rotate=0] at  (3cm, -10cm) {\dots\dots};
      \drawboxwitharrows{0}{green/0.4, red/0.05}{dummy}                                       {-3}   {6cm,   -10cm}{none}
      \drawboxwitharrows{0}{green/0.4, red/0.05}{dummy}                                       {-2}   {7cm,   -10cm}{none}
      \drawboxwitharrows{0}{green/0.4, red/0.05}{dummy}                                       {-1}   {8cm,   -10cm}{none}
       \draw (-4.5cm,    -10.5cm) -- (-2.5cm, -10.5cm);
        \draw (-2.2cm, -10.5cm) -- (0.4cm, -10.5cm);
        \draw (5.7cm, -10.5cm) -- (8.5cm, -10.5cm);

            %%% DOTS
      \node[rotate=-60] at  (-1cm, -12.2cm) {\dots\dots\dots};    
      \node[rotate=90] at (3cm, -12.2cm) {\dots\dots\dots};        
      \node[rotate=60] at (7cm, -12.2cm) {\dots\dots\dots};      

        %%% DECK COUNT 32 LAYER END
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {0}    {-8cm,  -14cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {1}    {-7cm,  -14cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {2}    {-6cm,  -14cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {3}    {-5cm,  -14cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {4}    {-4cm,   -14cm}{none}
      \node[rotate=0] at  (3cm, -14cm) {\dots\dots\dots\dots\dots\dots};
      \drawboxwitharrows{0}{green/0.4, red/0.05}{dummy}                                       {-3}   {10cm,   -14cm}{none}
      \drawboxwitharrows{0}{green/0.4, red/0.05}{dummy}                                       {-2}   {11cm,   -14cm}{none}
      \drawboxwitharrows{0}{green/0.4, red/0.05}{dummy}                                       {-1}   {12cm,   -14cm}{none}
       \draw (-4.5cm,    -10.5cm) -- (-2.5cm, -10.5cm);
        \draw (-2.2cm, -10.5cm) -- (0.4cm, -10.5cm);
        \draw (5.7cm, -10.5cm) -- (8.5cm, -10.5cm);

       \draw (-8.4cm,    -14.5cm) -- (-7.6cm, -14.5cm);
       \draw (-7.4cm,    -14.5cm) -- (-6.6cm, -14.5cm);
       \draw (-6.4cm,    -14.5cm) -- (-5.6cm, -14.5cm);
       \draw (-5.4cm,    -14.5cm) -- (-3.6cm, -14.5cm);
        \draw (9.7cm, -14.5cm) -- (12.5cm, -14.5cm);

        
        \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-8, -14.3) to[out=-140, in=-2] (-1, -16.3); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-8, -14.3) to[out=-100, in=-2] (-1, -16.3); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-7, -14.3) to[out=-120, in=1] (0, -16.3); 
          \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-7, -14.3) to[out=-90, in=1] (0, -16.3); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-6, -14.3) to[out=-120, in=-2] (-2, -16.3); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-6, -14.3) to[out=-90, in=-2] (-2, -16.3); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-5, -14.3) to[out=-120, in=-2] (-2, -16.3); 
          \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-5, -14.3) to[out=-90, in=-2] (-2, -16.3); 

          %%%%%%%%%%% RIGHT 
          \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -14.3) to[out=-60, in=10] (4, -16.3); 
            \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -14.3) to[out=-40, in=10] (4, -16.3); 
           \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -14.3) to[out=-60, in=10] (7, -16.3); 
           \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -14.3) to[out=-40, in=10] (7, -16.3); 
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (12, -14.3) to[out=-60, in=10] (5, -16.3); 
          \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (12, -14.3) to[out=-40, in=10] (5, -16.3); 

         
            %%% DOTS
      \node[rotate=90] at (1cm, -19cm) {\dots\dots\dots};        
      \node[rotate=90] at (3cm, -19cm) {\dots\dots\dots};        
      \node[rotate=90] at (5cm, -19cm) {\dots\dots\dots};        


       \drawboxwitharrows{0}{red/-0.2, blue!50/0.4, green/0.05}{dummy}{0}  {-1cm,  -22cm}{none}
      \drawboxwitharrows{0}{red/-0.2, blue!50/0.4, orange/0.05}{dummy}{1}  {0cm,   -22cm}{none}
       \drawboxwitharrows{0}{green/-0.2, blue!50/0.4, red/0.05}{dummy}{2}  {1cm,   -22cm}{none}
        \node[rotate=0] at (3cm, -22cm) {\dots\dots\dots};   
      \drawboxwitharrows{0}{black/-0.2, blue!50/0.4, orange/0.05}{dummy}{-3}  {5cm,  -22cm}{none}
      \drawboxwitharrows{0}{red/-0.2, blue!50/0.4, green/0.05}{dummy}{-2}  {6cm,   -22cm}  {none}
      \drawboxwitharrows{0}{black/-0.2, blue!50/0.4, red/0.05}{dummy}{-1}  {7cm,   -22cm}  {none}
            %%% DOTS
      \node[rotate=60] at (1cm, -25cm) {\dots\dots\dots};        
      \node[rotate=90]  at (3cm, -25cm) {\dots\dots\dots};        
      \node[rotate=-60]  at (5cm, -25cm) {\dots\dots\dots};    

             \drawboxwitharrows{0}{red/-0.2, blue!50/0.4, green/0.05}{dummy}{0}  {-5cm,  -28cm} {none}
      \drawboxwitharrows{0}{red/-0.2, blue!50/0.4, orange/0.05}{dummy}{1}        {-4cm,   -28cm}{none}
      \drawboxwitharrows{0}{green/-0.2, blue!50/0.4, red/0.05}{dummy}{2}         {-3cm,   -28cm}{none}
        \node[rotate=0] at (3cm, -28cm) {\dots\dots\dots\dots\dots\dots\dots\dots\dots\dots\dots\dots};   
      \drawboxwitharrows{0}{black/-0.2, blue!50/0.4, orange/0.05}{dummy}{-3}     {9cm,   -28cm} {none}
      \drawboxwitharrows{0}{red/-0.2, blue!50/0.4, green/0.05}{dummy}{-2}        {10cm,   -28cm}{none}
      \drawboxwitharrows{0}{black/-0.2, blue!50/0.4, red/0.05}{dummy}{-1}        {11cm,   -28cm}{none}

            \draw (-5.3cm,    -28.5cm) -- (-4.7cm, -28.5cm);
            \draw (-4.3cm,    -28.5cm) -- (-3.7cm, -28.5cm);
            \draw (-3.3cm,    -28.5cm) -- (-2.7cm, -28.5cm);
            \draw (8.7cm,    -28.5cm) -- (9.4cm, -28.5cm);
            \draw (9.7cm,    -28.5cm) -- (10.4cm, -28.5cm);
            \draw (10.7cm,    -28.5cm) -- (11.4cm, -28.5cm);

         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-5, -28.3) to[out=-70, in=60] (5, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-5, -28.3) to[out=-90, in=60] (5, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-80, in=60] (1, -30.7); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-60, in=60] (1, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-3, -28.3) to[out=-80, in=60] (2, -30.7); 
         \draw[black, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-3, -28.3) to[out=-60, in=60] (2, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-80, in=60] (1, -30.7); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-60, in=60] (1, -30.7); 
         \draw[black, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -28.3) to[out=-80, in=60] (4, -30.7); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -28.3) to[out=-60, in=60] (4, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (9, -28.3) to[out=-80, in=60] (3, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (9, -28.3) to[out=-60, in=60] (3, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -28.3) to[out=-80, in=60] (3, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -28.3) to[out=-60, in=60] (3, -30.7); 


         
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (5, -28.3) to[out=-80, in=60] (6, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (5, -28.3) to[out=-60, in=60] (6, -30.7); 

         
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (2, -28.3) to[out=-80, in=60] (7, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (2, -28.3) to[out=-60, in=60] (7, -30.7); 
         
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-2, -28.3) to[out=-80, in=60] (7, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-2, -28.3) to[out=-60, in=60] (7, -30.7); 


      \drawboxwitharrows{0}{}{dummy}{0}                     {1cm,  -31cm} {none}
      \drawboxwitharrows{0}{}{dummy}{1}                     {2cm,  -31cm} {none}
      \drawboxwitharrows{0}{}{dummy}{2}                     {3cm,  -31cm} {none}
      \drawboxwitharrows{0}{}{dummy}{3}                     {4cm,   -31cm}{none}
      \drawboxwitharrows{0}{}{dummy}{4}                     {5cm,   -31cm}{none}
      \drawboxwitharrows{0}{}{dummy}{5}                     {6cm,   -31cm}{none}
      \drawboxwitharrows{0}{}{dummy}{6}                     {7cm,   -31cm}{none}


    \end{tikzpicture}
    }
    \caption{Game Tree}
    \label{fig:gametreegeneration}
\end{figure}

\newpage

\begin{figure}
\centering
\scalebox{0.5}{
    \begin{tikzpicture}


        \node[rotate=0] at (-2, -4) {\Large Game Tree}; 
        \node[rotate=0] at (11, -4) {\Large Full Game Tree}; 
 \draw[->, very thick, decorate, decoration={snake, amplitude=2mm, segment length=5mm}] (2.5cm, -9cm) -- (4.5cm, -9cm);
        \node[rotate=0] at (3.5, -8) {\Large Unfold}; 
        
        %%% DECK COUNT 32 LAYER 0
      \drawboxwitharrows{0}{blue!50/0.4, red/0.05, green/-0.2}{dummy}{\py{0}}  {-2.5cm,  -8cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}{\py{1}}  {-1.5cm,   -8cm}{none}
     

       %%% DECK COUNT 32 LAYER 1
      \drawboxwitharrows{0}{blue!50/0.4, red/0.05, green/-0.2}{dummy}                                       {\py{0}}    {-4cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, red/0.05, green/-0.2}{dummy}                                       {\py{1}}    {-3cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {\py{2}}    {-2cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {\py{3}}    {-1cm,  -10cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}                                       {\py{4}}    {0cm,   -10cm}{none}
       \draw (-4.5cm,    -10.5cm) -- (-2.5cm, -10.5cm);
        \draw (-2.2cm, -10.5cm) -- (0.4cm, -10.5cm);
        %%%% RIGHT SIDE UP
         \drawboxwitharrows{0}{}{dummy}{\py{0}}  {9cm,   -7cm}{green}
         \drawboxwitharrows{0}{}{dummy}{\py{0}}  {10cm,  -7cm}{red}
         \drawboxwitharrows{0}{}{dummy}{\py{0}}  {11cm,  -7cm}{blue!50}
         \drawboxwitharrows{0}{}{dummy}{\py{1}}  {12cm,  -7cm}{orange}
         \drawboxwitharrows{0}{}{dummy}{\py{1}}  {13cm,  -7cm}{blue!50}
        %%%% RIGHT SIDE DOWN

         \drawboxwitharrows{0}{}{dummy}{\py{0}}  {6cm,   -11cm}{green}
         \drawboxwitharrows{0}{}{dummy}{\py{0}}  {7cm,   -11cm}{red}
         \drawboxwitharrows{0}{}{dummy}{\py{0}}  {8cm,   -11cm}{blue!50}
          \drawboxwitharrows{0}{}{dummy}{\py{1}} {9cm,   -11cm}{green}
         \drawboxwitharrows{0}{}{dummy}{\py{1}}  {10cm,  -11cm}{red}
         \drawboxwitharrows{0}{}{dummy}{\py{1}}  {11cm,  -11cm}{blue!50}
         \drawboxwitharrows{0}{}{dummy}{\py{2}}  {12cm,  -11cm}{orange}
         \drawboxwitharrows{0}{}{dummy}{\py{2}}  {13cm,  -11cm}{blue!50}
         \drawboxwitharrows{0}{}{dummy}{\py{3}}  {14cm,  -11cm}{orange}
         \drawboxwitharrows{0}{}{dummy}{\py{3}}  {15cm,  -11cm}{blue!50}
         \drawboxwitharrows{0}{}{dummy}{\py{4}}  {16cm,  -11cm}{orange}
         \drawboxwitharrows{0}{}{dummy}{\py{4}}  {17cm,  -11cm}{blue!50}


        %%% 

         \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (9, -7.25) to[out=-80, in=60] (6, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (9, -7.25) to[out=-80, in=60] (9, -10.75); 

        \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -7.25) to[out=-80, in=60] (7, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -7.25) to[out=-80, in=60] (10, -10.75); 


          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -7.25) to[out=-80, in=60] (8, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -7.25) to[out=-80, in=60] (11, -10.75); 

        \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (12, -7.25) to[out=-80, in=60] (12, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (12, -7.25) to[out=-80, in=60] (14, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (12, -7.25) to[out=-80, in=60] (16, -10.75); 

          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (13, -7.25) to[out=-80, in=60] (13, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (13, -7.25) to[out=-80, in=60] (15, -10.75); 
          \draw[thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (13, -7.25) to[out=-80, in=60] (17, -10.75); 


        %%% NODES UNDER 
        \node[rotate=0] at (4.5, -11.5) {\py{{t\_edg = [}}}; 
         \node[rotate=0] at (6, -11.5) {\py{{0}}}; 
         \node[rotate=0] at (7, -11.5) {\py{{1}}}; 
         \node[rotate=0] at (8, -11.5) {\py{{2}}}; 
         \node[rotate=0] at (9, -11.5) {\py{{0}}}; 
         \node[rotate=0] at (10, -11.5) {\py{{1}}}; 
         \node[rotate=0] at (11, -11.5) {\py{{2}}}; 
         \node[rotate=0] at (12, -11.5) {\py{{3}}}; 
         \node[rotate=0] at (13, -11.5) {\py{{4}}}; 
         \node[rotate=0] at (14, -11.5) {\py{{3}}}; 
         \node[rotate=0] at (15, -11.5) {\py{{4}}}; 
         \node[rotate=0] at (16, -11.5) {\py{{3}}}; 
         \node[rotate=0] at (17, -11.5) {\py{{4}}}; 
         \node[rotate=0] at (18, -11.5) {\py{]}}; 
    \end{tikzpicture}
    }
\caption{Unfolding Process \& In-Hand Update}
    \label{fig:in_hand_update}
\end{figure}

This section is organized as follows. First, in Subsection~\ref{sec:gametensor}, we describe the construction of the \emph{Game Tensors}. Next, Subsection~\ref{sec:actions} explains how the \emph{Action Tensors} are built and how they are used to update the Game Tensors. Then, in Subsection~\ref{sec:inhandupdates}, we detail how the \py{t\_fgm} tensor is updated within each round; this subsection also introduces the construction of the Edge Tensor \py{t\_edg}. Following that, Subsection~\ref{sec:bethand} describes the Between-Hand updates, including how the Score Tensor and Full Game Tensor are updated at the end of each round, along with the Linkage Tensor \py{t\_lnk}. Subsection~\ref{sec:scoretensor} discusses the update process for the In-Play Cards and Out-of-Play Cards tensors. Finally, Subsection~\ref{sec:infosettensor} explains how the Infoset Tensors are constructed.

\subsection{Game Tensor}\label{sec:gametensor}
Each row in the game tree (Figure~\ref{fig:gametreegeneration}) is represented using an \py{M*3*N} Game Tensor \py{t\_gme}, where \py{M} corresponds to the number of nodes in that layer of the tree. The the associated \py{3*N} tensor is constructed for each node:

Each slice \py{t\_gme[i,:,:]} encodes a single game state. The first row of the tensor, \py{t\_gme[0,:]}, represents the current card holdings and pool status. To encode the game state numerically, we assign integer identifiers to the entities involved, as shown in Table~\ref{tab:state_encoding}.

\begin{table}[h!]
\centering
\caption{State Encoding in \py{t\_gme[0,:]}}
\label{tab:state_encoding}
\begin{tabular}{ll}
\toprule
\textbf{Element} & \textbf{Encoding} \\
\midrule
Alex                 & 1 \\
Bob                  & 2 \\
Pool                 & 3 \\
\bottomrule
\end{tabular}
\end{table}

The remaining two rows of \py{t\_gme}, namely \py{t\_gme[1,:]} and \py{t\_gme[2,:]}, record the action histories of Alex and Bob, respectively. We describe the construction of \py{t\_gme[1,:]} in detail below; the construction of \py{t\_gme[2,:]} is analogous.

Each round consists of four turns, meaning that Alex plays a card four times per round. During each turn \py{i\_trn = i}, for \py{i = 0, 1, 2, 3}, he may or may not collect cards from the pool.

Suppose Alex plays the card $\AH$ on his first turn and collects $\TeH$. We update \py{t\_gme[1,:]} by recording the value \py{1} at the position corresponding to $\AH$, and adding the value \py{10} at the position corresponding to $\TeH$. If Alex collects multiple cards from the pool on his first turn, the value \py{10} is added to all corresponding positions in \py{t\_gme[1,:]} for each collected card. For subsequent turns, similar updates are performed, except we use the value pairs \py{2,20}, \py{3,30}, and \py{4,40} instead of \py{1,10} for the second, third, and fourth turns, respectively.

Importantly, \py{t\_gme[0,:]} is updated after each move to reflect the current state of the game. For cards that are played but not collected, the corresponding position in \py{t\_gme[0,:]} is set to \py{3}. If a played card is used to collect one or more cards from the pool, then the corresponding positions are updated as follows: hand cards that were played or picked change from \py{1} to \py{0}, and pool cards that were collected change from \py{3} to \py{0}. See CodeSnippet \ref{alg:applyactions}.

\subsubsection{Compressed Game Tensor}
In this subsection, we represent a game tensor \py{t\_gme} of shape \py{[M, 3, N]} using a compressed form \py{t\_cmp} of shape \py{[M, N]}. This compressed tensor is later used to build the Infoset representation in Section~\ref{sec:infosettensor}. During Game Tree construction, all resulting \py{t\_cmp} tensors are stored, and it becomes straightforward to mask information not observable by the acting player through simple masking operations. Next, we describe how \py{t\_cmp} is constructed and explain why this construction uniquely encodes a Game Tree layer, given the current In-Play tensor \py{t\_inp}. See CodeSnippet~\ref{cs:compressedgametensor}.

\begin{algorithm}
\caption{Compressed Game Tensor}
\label{cs:compressedgametensor}
\begin{algorithmic}[1]
\State \textbf{Input:} \py{t\_gme}
\State \py{t\_cmp} $\gets$ \py{t\_gme[:,1,:] - t\_gme[:,2,:]}
\State \py{t\_lpm} $\gets$ \py{logical\_and(t\_gme[:,0,:] == 0, t\_cmp != 0)}
\State \py{t\_cmp[t\_lpm]} $\gets$ \py{110 + t\_cmp[t\_lpm]}

\vspace{1mm}

\State \py{t\_cmp[logical\_and(t\_gme[:,0,:] == 3, t\_cmp == 0)]} $\gets$ \py{110}
\State \py{t\_cmp[logical\_and(t\_gme[:,0,:] == 1, t\_cmp == 0)]} $\gets$ \py{100}
\State \py{t\_cmp[logical\_and(t\_gme[:,0,:] == 2, t\_cmp == 0)]} $\gets$ \py{105}
\end{algorithmic}
\end{algorithm}

In Table~\ref{table:compressedgametensor}, we summarize all possible values that can appear in the compressed tensor \py{t\_cmp} (see CodeSnippet~\ref{cs:compressedgametensor}). Each card can have up to two \emph{legs} in a round. The first leg corresponds to when the card is \emph{laid} into the pool, and the second leg corresponds to when it is \emph{picked} from the pool. A card may have only one leg in the current layer of the game tensor—this occurs when a player lays the card into the pool, but it has not yet been picked by any player. Alternatively, a card may have no legs in the current round; this happens when the card was already in the pool at the start of the round or is still held by one of the players. By design of the game tensor \py{t\_gme}, we can characterize these situations precisely:

\begin{table}[H]
\centering
\scriptsize
\caption{Leg Status Conditions for Cards}
\label{table:card_leg_conditions}
\begin{tabular}{
>{\centering\arraybackslash}p{5cm}
>{\centering\arraybackslash}p{5cm}
>{\centering\arraybackslash}p{5cm}
}
\toprule
\textbf{No Legs} & \textbf{One Leg} & \textbf{Both Legs in Same Turn} \\
\midrule
\py{t\_cmp==0} & \py{t\_gme[:,0,:]==3} and \py{t\_cmp!=0} & \py{t\_gme[:,0,:]==0} and \py{t\_cmp!=0} \\
\bottomrule
\end{tabular}
\end{table}


% In Table \ref{table:compressedgametensor}, we provide all the possible values inside the compressed tensor \py{t\_cmp} \ref{cs:compressedgametensor}. Each card may have up to two \emph{legs}. The first leg corresponds to when the card is \emph{laid} into the pool, and the second leg corresponds to when it is \emph{picked} from the pool. A card may have only one leg in the current layer of the game tensor. This occurs when a player lays the card into the pool, but it has not yet been picked by any player. Alternatively, a card may have no legs in the current round—this happens when the card was already in the pool at the start of the round or is still held by one of the players. Notice that by design of the game tensor \py{t\_gme}, a card has no leg upto current round if and only if \py{t\_cmp==0}. Moreover, a card has only one leg if and only if \py{t\_gme[:,0,:]==3} and \py{t\_cmp!=0}. Finally, a card's first and second leg happen at the same turn if and only if \py{t\_gme[:,0,:]==0} and \py{t\_cmp!=0}.

% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp!=0)]} $\gets$ \py{110+t\_cmp} Alex laid and picked at i_trn = 0
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==1)]} $\gets$ \py{111} Alex laid and picked at i_trn = 0
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==2)]} $\gets$ \py{112} Alex laid and picked at i_trn = 1
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==3)]} $\gets$ \py{113} Alex laid and picked at i_trn = 2
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==4)]} $\gets$ \py{114} Alex laid and picked at i_trn = 3
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==-1)]} $\gets$ \py{109} Alex laid and picked at i_trn = 0
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==-2)]} $\gets$ \py{108} Alex laid and picked at i_trn = 1
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==-3)]} $\gets$ \py{107} Alex laid and picked at i_trn = 2
% \State \py{t\_cmp[logical\_and(t\_gme[:,0,:]==0, t\_cmp==-4)]} $\gets$ \py{106} Alex laid and picked at i_trn = 3

% Value & First Leg & Second Leg & Description 
% 100 &   &  & Held by Alex
% 105 &   &  & Held by Bob
% 110 &   &  & Was already in the pool
% 111 &   Alex laid at \py{i\_trn=0}&   & Alex picked at \py{i\_trn=0}
% 112 &   Alex laid at \py{i\_trn=1}&   & Alex picked at \py{i\_trn=1}
% 113 &   Alex laid at \py{i\_trn=2}&   & Alex picked at \py{i\_trn=2}
% 114 &   Alex laid at \py{i\_trn=3}&   & Alex picked at \py{i\_trn=3}
% 109 &   Bob laid at \py{i\_trn=0} &   & Bob picked at \py{i\_trn=0}
% 108 &   Bob laid at \py{i\_trn=1} &   & Bob picked at \py{i\_trn=1}
% 107 &   Bob laid at \py{i\_trn=2} &   & Bob picked at \py{i\_trn=2}
% 106 &   Bob laid at \py{i\_trn=3} &   & Bob picked at \py{i\_trn=3}
% 1   & Alex laid at \py{i\_trn=0}  & has not picked yet           &
% -9  & Alex laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=0}  & 
% -19 & Alex laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=1}  & 
% -29 & Alex laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=2}  & 
% -39 & Alex laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=3}  & 
% 21  & Alex laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=1} &  
% 31  & Alex laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=2} &  
% 41  & Alex laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=2} &  
% 2   & Alex laid at \py{i\_trn=1}  & has not picked yet           &
% -18  & Alex laid at \py{i\_trn=1}  & Bob picked at \py{i\_trn=1}  & 
% -28 & Alex laid at \py{i\_trn=1}  & Bob picked at  \py{i\_trn=2}  & 
% -38 & Alex laid at \py{i\_trn=1}  & Bob picked at \py{i\_trn=3}  & 
% 32  & Alex laid at \py{i\_trn=1}  & Alex picked at \py{i\_trn=2} &  
% 42  & Alex laid at \py{i\_trn=1}  & Alex picked at \py{i\_trn=3} &  
% 3   & Alex laid at \py{i\_trn=2}  & has not picked yet           &
% -27  & Alex laid at \py{i\_trn=2}  & Bob picked at \py{i\_trn=2}  & 
% -37 & Alex laid at \py{i\_trn=2}  & Bob picked at  \py{i\_trn=3}  & 
% 43  & Alex laid at \py{i\_trn=2}  & Alex picked at \py{i\_trn=3} &  


% -1   & Bob laid at \py{i\_trn=0}  & has not picked yet           &
% 9    & Bob laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=0}  & 
% 19   & Bob laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=1}  & 
% 29   & Bob laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=2}  & 
% 39   & Bob laid at \py{i\_trn=0}  & Alex picked at \py{i\_trn=3}  & 
% -21  & Bob laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=1} &  
% -31  & Bob laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=2} &  
% -41  & Bob laid at \py{i\_trn=0}  & Bob picked at \py{i\_trn=2} &  
% -2   & Bob laid at \py{i\_trn=1}  & has not picked yet           &
% 28   & Bob laid at \py{i\_trn=1}  & Alex picked at \py{i\_trn=2}  & 
% 38   & Bob laid at \py{i\_trn=1}  & Alex picked at  \py{i\_trn=3}  & 
% -32  & Bob laid at \py{i\_trn=1}  & Bob picked at \py{i\_trn=2}  & 
% -42  & Bob laid at \py{i\_trn=1}  & Bob picked at \py{i\_trn=3} &  
% -3   & Bob laid at \py{i\_trn=2}  & has not picked yet           &
% 37   & Bob laid at \py{i\_trn=2}  & Alex picked at \py{i\_trn=3}  & 
% -43   & Bob laid at \py{i\_trn=2}  & Bob picked at \py{i\_trn=3} &  

\begin{table}[H]
\centering
\scriptsize
\caption{Compressed Game Tensor Values in \py{t\_cmp}}
\label{table:compressedgametensor}
\begin{tabular}{c c c l}
\toprule
\textbf{Value} & \textbf{First Leg} & \textbf{Second Leg} & \textbf{Description} \\
\midrule
\py{100} & — & — & Held by Alex \\
\py{105} & — & — & Held by Bob \\
\py{110} & — & — & Was already in the pool \\
\midrule
\py{111,112,113,114} & Alex laid at $\py{i\_trn=0:3}$ & Alex picked at same turn & Both legs in same turn by Alex \\
\py{109,108,107,106} & Bob laid at $\py{i\_trn=0:3}$ & Bob picked at same turn & Both legs in same turn by Bob \\
\midrule
\py{1,2,3,4} & Alex laid at $\py{i\_trn=0:3}$ & — & Not yet picked \\
\py{-1,-2,-3,-4} & Bob laid at $\py{i\_trn=0:3}$ & — & Not yet picked \\
\midrule
\py{-9,-19,-29,-39} & Alex laid at \quad$\py{i\_trn=0}$ & Bob picked at $\py{i\_trn=0:3}$ & \\
\py{-18,-28,-38} & Alex laid at \quad$\py{i\_trn=1}$ & Bob picked at $\py{i\_trn=1:3}$ & \\
\py{-27,-37} & Alex laid at \quad$\py{i\_trn=2}$ & Bob picked at $\py{i\_trn=2:3}$ & \\
\py{21,31,41} & Alex laid at \quad$\py{i\_trn=0}$ & Alex picked at $\py{i\_trn=1:3}$ & \\
\py{32,42} & Alex laid at \quad$\py{i\_trn=1}$ & Alex picked at $\py{i\_trn=2:3}$ & \\
\py{43} & Alex laid at \quad$\py{i\_trn=2}$ & Alex picked at \quad$\py{i\_trn=3}$ & \\
\midrule
\py{19,29,39} & Bob laid at \quad$\py{i\_trn=0}$ & Alex picked at $\py{i\_trn=1:3}$ & \\
\py{28,38} & Bob laid at \quad$\py{i\_trn=1}$ & Alex picked at $\py{i\_trn=2:3}$ & \\
\py{37} & Bob laid at \quad$\py{i\_trn=2}$ & Alex picked at \quad$\py{i\_trn=3}$ & \\
\py{-21,-31,-41} & Bob laid at \quad$\py{i\_trn=0}$ & Bob picked at $\py{i\_trn=1:3}$ & \\
\py{-32,-42} & Bob laid at \quad$\py{i\_trn=1}$ & Bob picked at $\py{i\_trn=2:3}$ & \\
\py{-43} & Bob laid at \quad$\py{i\_trn=2}$ & Bob picked at \quad$\py{i\_trn=3}$ & \\
\bottomrule
\end{tabular}
\end{table}



% % % % % % 
%  ACTIONS
% % % % % % 
\subsection{Actions}\label{sec:actions}

At each turn, we first compute two key tensors: the \emph{Branch Factor Tensor} \py{t\_brf} and the \emph{Action Tensor} \py{t\_act}: \py{t\_brf} is a tensor of length \py{M}, where \py{M} is the number of nodes in the current round. Each entry \py{t\_brf[i]} records the number of valid actions available from node \py{i}. Correspondingly, \py{t\_act} is a binary tensor of shape \py{[M',2,N]}, where \py{N} is the number of in-play cards. Here, \py{M'=t\_brf.sum()} is the total number of resulting nodes in the next round, created by enumerating all valid actions from the current nodes.

Each slice \py{t\_act[j,:,:]} encodes a single action and consists of two rows:
\begin{itemize}
    \item The first row \py{t\_act[j,0,:]} encodes the \emph{lay card}. It contains exactly one \py{1} indicating the played card, with zeros elsewhere.
    \item The second row \py{t\_act[j,1,:]} encodes the \emph{picked cards} from the pool. This row may contain zero or more \py{1}s depending on the number of cards picked in that action.
\end{itemize}

To update the game state tensor \py{t\_gme} for the next round, we first replicate each current node \py{i} according to its corresponding \py{t\_brf[i]} count, effectively expanding \py{t\_gme} to match the total number of action slices \py{M'}.  This is done using a Kronecker product:
\begin{center}
    \py{t\_gme} $\gets$ \py{t\_gme} $\otimes$ \py{t\_brf}
\end{center}
This expansion ensures that each valid action is paired with its own copy of the corresponding game state. Then, each slice of \py{t\_act} is applied to the corresponding replicated game state to produce the updated states, as shown in CodeSnippet~\ref{alg:applyactions}. Finally, we apply the encoded actions by updating \py{t\_gme} using \py{t\_act}, as detailed in CodeSnippet~\ref{alg:applyactions}. 



% % % % % % 
%  FIND ACTIONS
% % % % % % 
\subsubsection{Find Actions}
In this subsection, we present how Action Tensor \py{t\_act} is constructed using Game Tensor \py{t\_gme}.

% \floatname{algorithm}{CodeSnippet}
\begin{algorithm}
\caption{ApplyActions}
\label{alg:applyactions}
\begin{algorithmic}[1]
\State Input \py{t\_gme, t\_act, i\_ply, i\_trn}
\Statex \textcolor{green!50!black}{\scriptsize \# \py{t\_act.shape[0] = t\_gme.shape[0]} after expansion \py{t\_gme} $\gets$ \py{t\_gme} $\otimes$ \py{t\_brf}}
\State \py{t\_mpk} $\gets$ \py{any(t\_act[:,1,:], dim=1)}
\Statex \textcolor{green!50!black}{\scriptsize \# Whether a pick action occurs}

\State \py{t\_gme[t\_mpk,0,:]+=(2-i\_ply)*t\_act[t\_mpk,0,:]}
\Statex \textcolor{green!50!black}{\scriptsize \# Add lay card to pool (only if no pick)}

\State \py{t\_gme[t\_mpk,0,:]-=(1+i\_ply)*t\_act[t\_mpk,0,:]}
\Statex \textcolor{green!50!black}{\scriptsize \# Remove lay card from player's hand}

\State \py{t\_gme[t\_mpk,0,:]-=3*t\_act[t\_mpk,1,:]}
\Statex \textcolor{green!50!black}{\scriptsize \# Remove picked cards from the pool}

\State \py{t\_gme[:,i\_ply+1,:]+=(i\_trn+1)*t\_act[:,0,:]+10*(i\_trn+1)*t\_act[:,1,:]}
\Statex \textcolor{green!50!black}{\scriptsize \# Update player record: lay (weighted by i\_trn+1) + pick (weighted by 10 × i\_trn+1)}
\end{algorithmic}
\end{algorithm}
\subsection{Score Tensors}\label{sec:scoretensor}

There are two types of score tensors: those that store the score accumulated within a single round, called the \emph{running score tensor} \py{t\_rus}, and those that are passed along edges in the Game Tree, referred to as the \emph{score tensor} \py{t\_scr}.  The tensor \py{t\_rus} is initialized to zero at the beginning of each round and is updated after every turn. At the end of the round, the final value of \py{t\_rus} is used to update \py{t\_scr}. Table~\ref{table:score_tensor} outlines the meaning of each index in the score tensor \py{t\_scr}. In contrast, the running-score tensor \py{t\_rus} contains additional components relevant during a single round, which are described in Table~\ref{table:rus_tensor}.

\begin{table}[H]
    \centering
    \scriptsize
    \caption{Column definitions for the score tensor}
    \begin{tabular}{
        >{\centering\arraybackslash}p{2.8cm}
        >{\centering\arraybackslash}p{2.8cm}
        >{\centering\arraybackslash}p{2.8cm}
        >{\centering\arraybackslash}p{2.8cm}
        }
        \toprule
        \textbf{Alex Club} & \textbf{Bob Club} & \textbf{Point Difference} & \textbf{7-Clubs Bonus} \\
        \midrule
        \py{0} & \py{1} & \py{2} & \py{3} \\
        \bottomrule
    \end{tabular}
    \label{table:score_tensor_cols}
\end{table}

\begin{table}[H]
    \centering
    \scriptsize
    \caption{Column definitions for the running-score tensor}
    \begin{tabular}{
        >{\centering\arraybackslash}p{1.8cm}
        >{\centering\arraybackslash}p{1.8cm}
        >{\centering\arraybackslash}p{1.8cm}
        >{\centering\arraybackslash}p{1.8cm}
        >{\centering\arraybackslash}p{1.8cm}
        >{\centering\arraybackslash}p{1.8cm}
        >{\centering\arraybackslash}p{1.8cm}
        }
        \toprule
        \textbf{Alex Club} & \textbf{Bob Club} & \textbf{Last Picker} & \textbf{Alex Points} & \textbf{Alex Sur} & \textbf{Bob Points} & \textbf{Bob Sur} \\
\midrule
\py{0} & \py{1} & \py{2} & \py{3} & \py{4} & \py{5} & \py{6} \\
\bottomrule
\end{tabular}
\label{table:running_score_cols}
\end{table}
The Full Game Tensor \py{t\_fgm} is used to track which scores accumulated from previous rounds (stored in \py{t\_scr}) are linked to each node of the Game Tree tensor \py{t\_gme}. A row entry \py{[i, s]} in \py{t\_fgm} indicates that node \py{t\_gme[i]} inherits the score \py{t\_scr[s]} from a previous round. For example, during the first round (\textit{i.e.}, \py{i\_rnd = 0}), the second column of \py{t\_fgm} is identically \py{0}, since \py{t\_scr} has shape \py{[1, 4]} at this point. In other words, the only available score from previous rounds is \py{[0, 0, 0, 0]}. Figure~\ref{fig:gametreegeneration} illustrates this point, where all edges corresponding to the first round are highlighted in red.

% d_snw = {'a_clb':0,'b_clb':1,'pts_dlt':2, 'lst_pck':3,'a_pts':4,'a_sur':5,'b_pts':6,'b_sur':7}
\begin{figure}[h]
  \centering
\[
\py{t\_scr} = 
\begin{bmatrix}
\tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\end{bmatrix},
\qquad
\py{t\_fgm} = \begin{bmatrix}
\py{0} & \tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); 
\end{bmatrix}
\]
\caption{An example illustrating how the Full Game Tensor \py{t\_fgm} associates nodes in the Game Tree with entries in the Score Tensor \py{t\_scr}. Colors are used to indicate rows of \py{t\_scr}, consistent with Figure~\ref{fig:gametreegeneration}. Each row of \py{t\_scr} is represented by a tensor of size~4, as described in Table~\ref{table:score_tensor_cols}.}
  \label{fig:t_fgm_example}
\end{figure}

\subsection{In-Hand Updates}\label{sec:inhandupdates}
In this section, we explain how in-hand updates are performed. Before proceeding, we introduce a generalized version of \py{torch.repeat\_interleave}, referred to as \textbf{RepeatBlocks}, which will be used throughout this section. Unlike \py{torch.repeat\_interleave}, which repeats individual elements, RepeatBlocks operates on and repeats entire contiguous blocks of elements. This operation is described in detail in the next subsection.

\subsubsection{RepeatBlocks}
RepeatBlocks is a generalization of \py{torch.repeat\_interleave} in which, instead of repeating individual elements, entire blocks of elements are repeated. Each block has a custom size and a custom repetition count.  The idea is best explained through an example. Consider the following
 \[
\py{t\_org = [1,2,3,4,5,6], t\_bsz = [2,3,1],t\_rpt = [1,3,2]}
 \]
Here \py{t\_org,t\_bsz,t\_rpt} are the input tensor, block sizes, and repeat counts respectively. The desired output denoted by $\py{t\_org} \otimes_{\py{t\_bsz}}\py{t\_rpt}$ is 
\[
\py{t\_org} \otimes_{\py{t\_bsz}}\py{t\_rpt = [1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5, 6, 6]}
\]
For convenience, let us denote \py{t\_rbk} = \py{t\_org} $\otimes_{\py{t\_bsz}}$\py{t\_rpt}.
To construct \py{t\_rbk}, it suffices to build the corresponding index tensor \py{t\_idx}.
\[
\py{t\_idx = [0, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 5, 5]}
\]
Note that \py{t\_rbk = t\_org[t\_idx]}. Next, consider the corresponding start indices of each repeated block 
\[
\py{t\_blk = [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5],}
\]
It is emphasized that using input tensors, \py{t\_blk} is given as below.
\[
 \py{t\_blk = (cat([0,t\_bsz[:-1]])$\otimes$\py{t\_rpt})}\otimes (\underbrace{\py{t\_bsz$\otimes$t\_rpt}}_{:=\py{t\_bls}}) 
\]
Deducting \py{t\_blk} from \py{t\_idx}, we arrive at the following tensor.
\[
\py{t\_pos = [0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0]}
\]
Next, 
\[
\py{arange(t\_blk.shape[0])-t\_pos = [ 0,  0,  2,  2,  2,  5,  5,  5,  8,  8,  8, 11, 12]}
\]
 where a simple examination shows that the RHS is equal
\[
\py{cumsum(cat([0, t\_bls[:-1]]))$\otimes$t\_bls}.
\]
Putting pieces together, we arrive at Algorithm \ref{alg:RepeatBlocks}.
\begin{algorithm}
\caption{RepeatBlocks }
\label{alg:RepeatBlocks}
\begin{algorithmic}[1]
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
\State Input \py{t\_org, t\_bsz, t\_rpt}
\Statex \textcolor{green!50!black}{\scriptsize \# \py{t\_org:input tensor, t\_bsz:blocks sizes, t\_rpt:repeat counts}}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_org = [1,2,3,4,5,6], t\_bsz = [2,3,1],t\_rpt = [1,3,2]}}
%%%%%%%%%%%%%%%
\State \py{t\_bgn} $\gets$ \py{cat([0,t\_bsz[:-1]])}$\otimes$\py{t\_rpt}
\Statex \textcolor{green!50!black}{\scriptsize \# Compute beginning indices of each output's block}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_bgn = [0, 2, 2, 2, 5, 5]}}
%%%%%%%%%%%%%%%
\State \py{t\_bls} $\gets$ \py{t\_bsz}$\otimes$\py{t\_rpt}
\Statex \textcolor{green!50!black}{\scriptsize \# Compute sizes of each output's block}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_bls = [2, 3, 3, 3, 1, 1]}}
%%%%%%%%%%%%%%%
\State \py{t\_blk} $\gets$ \py{t\_bgn}$\otimes$\py{t\_bls}
\Statex \textcolor{green!50!black}{\scriptsize \# t\_blk[i] = j i.e., output[i] belongs to block j}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_blk = [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5]}}
%%%%%%%%%%%%%%%
\State \py{t\_csm} $\gets$ \py{cumsum(0,t\_bls[:-1])}$\otimes$\py{t\_bls}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_csm=[ 0,  2,  5,  8, 11, 12]$\otimes$t\_bls=[ 0,  0,  2,  2,  2,  5,  5,  5,  8,  8,  8, 11, 12]}}
\State \py{t\_pos} $\gets$ \py{arange(i\_blk)-t\_csm}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_pos=[0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0]}}
%%%%%%%%%%%%%%%
\State \py{t\_idx} $\gets$ \py{t\_pos+t\_blk}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_idx=[0, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 5, 5]}}
%%%%%%%%%%%%%%%
\State \py{t\_rbk} $\gets$ \py{t\_org[t\_idx]}
\Statex \textcolor{green!50!black}{\scriptsize \# Ex: \py{t\_rbk=[1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5, 6, 6]}}
%%%%%%%%%%%%%%%

\State Output \py{t\_rbk} 
\Statex \textcolor{green!50!black}{\scriptsize \# denoted by \py{t\_org}$\otimes_{\py{t\_bsz}}$\py{t\_rpt}}
\end{algorithmic}
\end{algorithm}
\subsubsection{Full Game Tree}
In this section, we explain how the Full Game Tree is updated within each round. Two tensors are updated during this process: the Full Game Tensor \py{t\_fgm} and the Edge Tensor \py{t\_edg}, which captures the connections between nodes across successive layers of the Full Game Tree.

Figure~\ref{fig:in_hand_update} illustrates how the Edge Tensor \py{t\_edg} is constructed. On the left-hand side, we show two parent nodes—one with 2 child nodes and 3 inherited scores, and the other with 3 child nodes and 2 inherited scores. The right-hand side of the figure illustrates the corresponding structure within the Full Game Tree. Here, colors denote inherited scores from the previous round, and numbers represent the row indices from the current game tensor \py{t\_gm}. An edge is drawn when the score colors match and the nodes are connected in the folded Game Tree. In this example, the tensor
\[
\py{t\_edg = [0,1,2,0,1,2,3,4,3,4,3,4]}
\]
records the parent indices in the Complete Tree. The counts of inherited scores and available actions per parent are given by \py{c\_scr = [3,2]} and \py{t\_brf = [2,3]}, respectively. This structure can be generated compactly by the \textbf{RepeatBlocks} operator as follows:
\[
\py{t\_edg} \leftarrow \py{arange(t\_fgm.shape[0])} \otimes_{\py{c\_scr}} \py{t\_brf}.
\]
% where \py{arange(i\_fgm)} produces a range over parent indices, and the block-wise repetition aligns with the inherited score counts (\py{c\_scr}) and action branching factors (\py{t\_brf}). 

We will next explain how full game tensor \py{t\_fgm} is updated with an example provided in Figure \ref{fig:t_fgm}. Consider the example in Figure \ref{fig:in_hand_update} again with their \py{t\_fgm} tensors shown in Figure \ref{fig:t_fgm}. We update \py{t\_fgm} in two phases: first, we update \py{t\_fgm[:,1]}; then, we update \py{t\_gme} and \py{c\_scr} before continuing to update \py{t\_fgm[:,0]}. We have 
\[
    \py{t\_fgm[:,1]} \leftarrow 
    \begin{bmatrix}
        \tikz[baseline] \fill[green] (0,0) rectangle (0.2,0.2); &
        \tikz[baseline] \fill[red] (0,0) rectangle (0.2,0.2); &
        \tikz[baseline] \fill[fill=blue!50] (0,0) rectangle (0.2,0.2); &
        \tikz[baseline] \fill[orange] (0,0) rectangle (0.2,0.2); &
        \tikz[baseline] \fill[fill=blue!50] (0,0) rectangle (0.2,0.2); 
    \end{bmatrix}
    \otimes_{\py{[3,2]}}\py{[2,3]}
    \]
    where the first tensor on the right-hand side is \py{t\_fgm[:,1]}. The first three colors are repeated twice on the right-hand side of Figure~\ref{fig:t_fgm} because \py{t\_brf[0] = 2}, and the last two values are repeated three times because \py{t\_brf[1] = 3}. Therefore, the following is true.
    \[
        \py{t\_fgm[:,1]} \leftarrow \py{t\_fgm[:,1]}\otimes_{\py{c\_scr}} \py{t\_brf}
        \]
        Furthermore, 
        \[
            \py{t\_fgm[:,0]} \leftarrow \py{[0,1,2,3,4]$\otimes$[3,3,2,2,2]} 
            \]
            In words, each node in the second layer of the Game Tree is repeated as many times as the number of scores it inherited from the previous round. Namely, 
            \[
                \py{t\_fgm[:,0]}\leftarrow \py{arange(t\_gme.shape[0])$\otimes$c\_scr}
                \]
                Both \py{t\_gme} and \py{c\_scr} are updated in the equation above. 
                
\begin{figure}[h]
  \centering
\[
\begin{bmatrix}
\py{0} & \tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); 
\end{bmatrix}
\;
\qquad
\xrightarrow{\hspace{1cm}}
\qquad
\begin{bmatrix}
\py{0} & \tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{2} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{2} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{3} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{3} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{4} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{4} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);
\end{bmatrix}
\]
  \caption{An illustration of how \py{t\_fgm} is updated.}
  \label{fig:t_fgm}
\end{figure}



\subsection{Between-Hand Updates}\label{sec:bethand}
In this section, we introduce the processing framework used at the beginning of each hand. Figure~\ref{fig00:bethand} illustrates this process. By the end of each hand, we obtain a set of hyper-nodes, each associated with one or more inherited scores from previous rounds.

To begin, we identify the unique game states among all generated hyper-nodes. This is achieved via the following operation:
\[
\py{t\_gme, t\_edg = unique(t\_gme, dim=0, return\_inverse=True)}
\]
This assigns a unique index to each distinct game state (card configuration), and we update the first column of the Full Game tensor accordingly:
\[
\py{t\_fgm[:,0]} \leftarrow \py{t\_edg}
\]
Note that this is an intermediate step: the final version of \py{t\_fgm} will be updated and sorted later in the process.

Next, we determine how scores are passed from one hand to the next. That is, we construct the new \py{t\_fgm} tensor for the upcoming round. As shown in Figure~\ref{fig00:bethand}, a hyper-node (e.g., node 0) may map to another node (e.g., node 6) after applying the \py{unique} operation, with multiple distinct scores inherited from different incoming paths.

To propagate scores correctly, we take the score components from the previous round, stored in \py{t\_fgm[:,1]}, and add the scores earned during the current hand, recorded in \py{t\_rus}. We then concatenate these two components and identify the unique score combinations:
\begin{center}
\py{t\_prs} $\gets$ \py{cat([t\_fgm[:,1], t\_rus], dim=1)}
\end{center}
We apply the \py{unique} operation to extract distinct score transitions:
\begin{center}
\py{t\_prs, t\_pid} $\gets$ \py{unique(t\_prs, dim=0, return\_inverse=True)}
\end{center}
Each unique pair in \py{t\_prs} represents a total score passed to the next round, and is computed by summing the individual components:
\begin{center}
\py{t\_scr} $\gets$ \py{t\_prs[:,0] + t\_prs[:,1]}
\end{center}
Finally, we eliminate duplicate score values using another call to \py{unique}, and update both the \py{t\_scr} (score tensor) and the second column of \py{t\_fgm} accordingly:
\begin{align*}
\py{t\_scr}, \py{t\_fid} &\gets \py{unique(t\_scr, dim=0, return\_inverse=True)} \\
\py{t\_fgm[:,1]} &\leftarrow \py{t\_fid[t\_pid]}
\end{align*}

Figure~\ref{fig01:bethand} provides a visual example of this score propagation procedure.

% In this section, we introduce the processing framework at the beginning of each hand (see  Figure \ref{fig00:bethand} for an example). By the end of each hand, we obtain a set of hyper-nodes along with their inherited scores. We first identify the unique nodes among all the hyper-nodes per below
% \[
% \py{t\_inf, t\_edg = unique(t\_inf,dim=0,return\_inverse=True)} 
% \]
% We now can update  \py{t\_fgm[:,0]} as follows.
% \[
% \py{t\_fgm[:,0]} \leftarrow \py{t\_edge}
% \]
% It is emphasized that \py{t\_fgm} will be updated later and the final output will be sorted. Next, we determine the scores that each node passes on to the next hyper-node—or equivalently, how \py{t\_fgm} is constructed at the beginning of each hand. For instance, in Figure~\ref{fig00:bethand}, hyper-node \py{0} is mapped to hyper-node \py{6} after applying the \py{unique} filter and hyper-node \py{6} inherits two distinct scores from hyper-node \py{0}, reflecting different paths or outcomes that converged into the same node.

% To construct \py{t\_fgm}, we take the \py{t\_fgm[:,1]} tensor from the end of the previous hand and combine it with \py{t\_rus}, which records the score earned solely from the play in the current round. We concatenate these two score components and extract the unique pairs from the resulting tensor. Then, for each unique pair, we compute its sum to obtain the total score passed to the next round. After applying the \py{unique} filter again to eliminate duplicates, we finalize both the updated score values and the new \py{t\_fgm} tensor to be used in subsequent rounds. Figure \ref{fig01:bethand} provides an example.


\begin{figure}
\centering
\scalebox{0.5}{
    \begin{tikzpicture}

             \drawboxwitharrows{0}{blue!50/0.4, green/0.05}{dummy}{0}  {-5cm,  -28cm} {none}
      \drawboxwitharrows{0}{blue!50/0.4, orange/0.05}{dummy}{1}        {-4cm,   -28cm}{none}
      \drawboxwitharrows{0}{green/-0.2, blue!50/0.4}{dummy}{2}         {-3cm,   -28cm}{none}
        \node[rotate=0] at (3cm, -28cm) {\dots\dots\dots\dots\dots\dots\dots\dots\dots\dots\dots\dots};   
      \drawboxwitharrows{0}{black/-0.2, blue!50/0.4}{dummy}{-3}     {9cm,   -28cm} {none}
      \drawboxwitharrows{0}{red/-0.2, blue!50/0.4}{dummy}{-2}        {10cm,   -28cm}{none}
      \drawboxwitharrows{0}{blue!50/0.4, red/0.05}{dummy}{-1}        {11cm,   -28cm}{none}

         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-5, -28.3) to[out=-70, in=60] (5, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-5, -28.3) to[out=-90, in=60] (5, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-80, in=60] (1, -30.7); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-60, in=60] (1, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-3, -28.3) to[out=-80, in=60] (2, -30.7); 
         \draw[black, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-3, -28.3) to[out=-60, in=60] (2, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-80, in=60] (1, -30.7); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-4, -28.3) to[out=-60, in=60] (1, -30.7); 
         \draw[black, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -28.3) to[out=-80, in=60] (4, -30.7); 
         \draw[orange, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (10, -28.3) to[out=-60, in=60] (4, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (9, -28.3) to[out=-80, in=60] (3, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (9, -28.3) to[out=-60, in=60] (3, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -28.3) to[out=-80, in=60] (3, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (11, -28.3) to[out=-60, in=60] (3, -30.7); 


         
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (5, -28.3) to[out=-80, in=60] (6, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (5, -28.3) to[out=-60, in=60] (6, -30.7); 

         
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (2, -28.3) to[out=-80, in=60] (7, -30.7); 
         \draw[red, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (2, -28.3) to[out=-60, in=60] (7, -30.7); 
         
         \draw[blue!50, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-2, -28.3) to[out=-80, in=60] (7, -30.7); 
         \draw[green, thick, decoration={markings, mark=at position 0.5 with {\arrow{>}}}, postaction={decorate}] (-2, -28.3) to[out=-60, in=60] (7, -30.7); 


      \drawboxwitharrows{0}{}{dummy}{0}                     {1cm,  -31cm} {none}
      \drawboxwitharrows{0}{}{dummy}{1}                     {2cm,  -31cm} {none}
      \drawboxwitharrows{0}{}{dummy}{2}                     {3cm,  -31cm} {none}
      \drawboxwitharrows{0}{}{dummy}{3}                     {4cm,   -31cm}{none}
      \drawboxwitharrows{0}{}{dummy}{4}                     {5cm,   -31cm}{none}
      \drawboxwitharrows{0}{}{dummy}{5}                     {6cm,   -31cm}{none}
      \drawboxwitharrows{0}{}{dummy}{6}                     {7cm,   -31cm}{none}


    \end{tikzpicture}
    }
    \caption{An illustration of between-hand processing}
      \label{fig00:bethand}
\end{figure}

\begin{figure}[h]
  \centering
\[
\begin{bmatrix}
\py{0} & \tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\py{0} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[green] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[red] (0,0) rectangle (0.2,0.2); \\
\py{1} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{2} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{2} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{3} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{3} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); \\
\py{4} & \tikz\fill[orange] (0,0) rectangle (0.2,0.2); \\
\py{4} & \tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);
\end{bmatrix}
\begin{bmatrix}
\tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[green, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[brown, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[black, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=brown, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\end{bmatrix}
\quad
\xrightarrow{\hspace{0.25cm}\py{cat}\hspace{0.25cm}}
\quad
\begin{bmatrix}
\tikz\fill[green] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[red] (0,0) rectangle (0.2,0.2);& \tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[green, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[green] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[red] (0,0) rectangle (0.2,0.2);& \tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange] (0,0) rectangle (0.2,0.2);& \tikz\fill[brown, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange] (0,0) rectangle (0.2,0.2);& \tikz\fill[black, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange] (0,0) rectangle (0.2,0.2);& \tikz\fill[fill=brown, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); & \tikz\fill[fill=blue!50, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\
\end{bmatrix}
\quad
\xrightarrow{\hspace{0.25cm}\py{unique}\hspace{0.25cm}}
\quad
\begin{bmatrix}
\tikz\fill[green] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[red] (0,0) rectangle (0.2,0.2);& \tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[green, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange] (0,0) rectangle (0.2,0.2);& \tikz\fill[brown, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[red, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[orange] (0,0) rectangle (0.2,0.2);& \tikz\fill[black, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2);& \tikz\fill[orange, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\ 
\tikz\fill[fill=blue!50] (0,0) rectangle (0.2,0.2); & \tikz\fill[fill=blue!50, rounded corners=2pt]               (0,0) rectangle (0.2,0.2); \\
\end{bmatrix}
\quad
\xrightarrow{\hspace{0.25cm}\py{sum}\hspace{0.25cm}}
\quad
\begin{bmatrix}
\tikz\fill[red] (0,0) circle (0.1); \\ 
\tikz\fill[green] (0,0) circle (0.1);  \\ 
\tikz\fill[fill=blue!50] (0,0) circle (0.1);  \\ 
\tikz\fill[fill=blue!50] (0,0) circle (0.1); \\ 
\tikz\fill[orange] (0,0) circle (0.1); \\ 
\tikz\fill[fill=blue!50] (0,0) circle (0.1);  \\ 
\tikz\fill[orange] (0,0) circle (0.1); \\ 
\tikz\fill[fill=blue!50] (0,0) circle (0.1); \\ 
\tikz\fill[fill=blue!50] (0,0) circle (0.1);  \\
\end{bmatrix}
\quad
\xrightarrow{\hspace{0.25cm}\py{unique}\hspace{0.25cm}}
\quad
\begin{bmatrix}
\tikz\fill[red] (0,0) circle (0.1); \\ 
\tikz\fill[green] (0,0) circle (0.1);  \\ 
\tikz\fill[fill=blue!50] (0,0) circle (0.1);  \\ 
\tikz\fill[orange] (0,0) circle (0.1); \\ 
\end{bmatrix}
\]
  \caption{An illustration of between-hand updates for \py{t\_fgm}.}
  \label{fig01:bethand}
\end{figure}
% \subsection{Unfolding Process}\label{sec:unfoldingprocess}

% % % % % % 
% INFOSET SECTION
% % % % % % 



\subsection{Infoset Tensors}\label{sec:infosettensor}
In this subsection, we represent each node of the Full Game Tree using the Infoset Tensor \py{t\_inf}, which has shape \py{[56]}. This tensor encodes all information available at that point in the game tree and can be easily adapted to mask any information not observable by the acting player. This design serves two primary purposes: first, to ensure memory efficiency; and second, to provide a compact representation of both the game state and associated action information, together with the corresponding strategy profile. These representations are later used to train a tree-based model to approximate the strategy profile, as described in Section~\ref{sec:tree}, and are subsequently used in self-play simulations, as detailed in Section~\ref{sec:Experimental}. It is important to emphasize that these infoset tensors are used only after the Nash equilibrium has been learned using the CFR algorithm. CodeSnippet \ref{cs:infosettensor} explains how \py{t\_inf} is constructed. 

\begin{algorithm}
\caption{Infoset Tensor}
\label{cs:infosettensor}
\begin{algorithmic}[1]
\State \py{t\_inf} $\gets$ \py{zeros((Q, 58), dtype=int8)}  \textcolor{green!50!black}{\scriptsize  \# \py{Q=t\_fgm.shape[0]}}
\State \py{t\_inf[:, t\_inp]}$\gets$\py{t\_cmp[t\_fgm[:,0]]}
\State \py{t\_inf[:,52:55]}$\gets$\py{t\_scr[t\_fgm[:,1]]}
\State \py{t\_inf[logical\_and(t\_dlt==1,t\_inf==0)]}$\gets$\py{-127}
\State \py{t\_inf[:,55:58]}$\gets$\py{tensor([i\_hnd,i\_trn,i\_ply])}
\end{algorithmic}
\end{algorithm}

Suppose the current layer of the Game Tree and the Full Game Tree contains \py{M} and \py{Q} nodes, respectively, as defined in Table~\ref{table:tensors}. That is, the tensors \py{t\_gme} and \py{t\_fgm} have \py{M} and \py{Q} rows, respectively. \py{t\_inf} consists of three distinct parts:

\begin{itemize}
    \item The first \py{52} indices are reserved for cards. These entries encode the current status or history of each card, depending on the information available at the node.
    \item The next three indices (\py{t\_inf[52:55]}) store score-related context inherited from the previous round, such as accumulated club points or point differential.
    \item The final three indices (\py{t\_inf[55:58]}) encode metadata, including the current round index, the turn counter, and an indicator specifying whose turn it is.
\end{itemize}

For any dealt card represented in \py{t\_dlt}, if that card is not present in the current game tensor \py{t\_gme}, we assign it a value of \py{-127} in \py{t\_inf} to indicate that the card has already been collected in one of the previous rounds.
% \floatname{algorithm}{CodeSnippet}
We need to clarify why no two rows of \py{t\_gme} will be mapped to the same compressed tensor. To this end, we summerize in Table ???, all the possible values inside the \py{t\_cmp}. 

% \State \py{t\_inf} $\gets$ \py{zeros((Q, 58), dtype=int8)}
% \State \py{t\_inf[:, t\_inp]}$\gets$\py{t\_tmp[t\_fgm[:,0]]}
% \State \py{t\_inf[:,52:55]}$\gets$\py{t\_scr[t\_fgm[:,1]]}
% \State \py{t\_inf[logical\_and(t\_gme[:,0,:]==3, t\_inf==0)]}$\gets$\py{110}



% \State \py{t\_inf[logical\_and(t\_gme[:,0,:]==i\_ply+1,t\_inf==0)]}$\gets$\py{100}


% \State \py{t\_inf[logical\_and(pad(t\_dlt, (0,6))==1,t\_inf==0)]}$\gets$\py{-127}


% \State \py{t\_inf[:,55:58]}$\gets$\py{tensor([i\_hnd,i\_trn,i\_ply])}


% The Card state resets at the beginning of each round the history action is erased. Also each game

% We represent the Game Tree using hypernodes. Each hypernode 

% At the end of each round, we calculate three quantities:
% \begin{itemize}
%     \item The number of clubs collected by Alex,
%     \item The number of clubs collected by Bob, and
%     \item The point difference (Alex minus Bob).
% \end{itemize}

% At the end of each round, we consider two game states to be identical if they share the same values for these three quantities and have the same pool state—that is, the set of cards currently in the pool. 

% This approach allows nodes in later rounds of the game tree to inherit scores from multiple earlier paths. Figure~\ref{fig00:bethand} illustrates this idea: different colors correspond to different triples of (Alex clubs, Bob clubs, point difference).

% \input{figs/fig00_bethand}

% In view of this, we refer to each node in our game tree as a \emph{hypernode}, which may inherit multiple score combinations from previous rounds. We track these score inheritances using the \textit{Full Game Tensor} \py{t\_fgm}, which records the score paths leading into each hypernode.

% At the end of each round, we sum the scores earned during that round and use them to update \py{t\_fgm}. In parallel, we maintain a list of all possible score combinations from previous rounds. This list is also updated alongside \py{t\_fgm} at the end of each round.




% The Game Tree consists of multiple tensors. It is emphasized that game tree generations does not care about hiding information from any of the players. It simply lists all the possibilities. 
% \begin{itemize}
%     \item Mask Tensor: We maintain a boolean tensor \py{t\_inp} to indicate which cards from the deck have already been dealt or are currently present in the pool.  
%     \item Game Tensor: Game tensor \py{t\_gme} which is a \py{M*3*N} tensors.   
% \end{itemize}


% We provide certain data structures to lower the memory usage. 




% We begin by describing how we represent the game state. A $3 \times N$ \textit{Game Tensor} \py{t\_gme} where \py{t\_gme.dtype=int8} is used for this purpose. It is emphasized that game tensors are used to generate the entire game tree, and therefore, it may contain information that is hidden from one of the players during actual gameplay.

% The first row of the tensor, \py{t\_gme[0,:]}, encodes one of the following: the cards held by Alex, the cards held by Bob, or the cards currently in the pool. To encode the game state numerically, we assign integer identifiers to each player and game element as shown in Table~\ref{tab:state_encoding}.

% \begin{table}[h!]
% \centering
% \caption{State Encoding in \py{t\_gme[0,:]}}
% \label{tab:state_encoding}
% \begin{tabular}{ll}
% \toprule
% \textbf{Element} & \textbf{Encoding} \\
% \midrule
% Alex                 & 1 \\
% Bob                  & 2 \\
% Pool                 & 3 \\
% % Faced up and collected & -127 \\
% \bottomrule
% \end{tabular}
% \end{table}
% At each stage of the game, we maintain a boolean tensor \py{t\_inp} to indicate which cards from the deck have already been dealt or are currently present in the pool. For example, for a game tensor \py{t\_gme}
% \begin{center}
% \py{t\_gme.shape[0]=t\_inp.sum()}
% \end{center}
% Additionally, we use another tensor, \py{t\_ndd}, to record which cards have been collected. We update \py{t\_inp} and \py{t\_out} at the end of each round. 

% The remaining two rows of \py{t\_gme}, namely \py{t\_gme[1,:]} and \py{t\_gme[2,:]}, record the action histories of Alex and Bob, respectively. We describe the construction of \py{t\_gme[1,:]} in detail below; the construction of \py{t\_gme[2,:]} is done analogously.


% Each round consists of 4 turns, meaning that Alex plays a card four times per round. During each turn \py{i\_trn = i}, for \py{i = 0, 1, 2, 3}, he may or may not collect cards from the pool. 

% Suppose Alex plays the card $\AH$ on his first turn and collects $\TeH$. We update \py{t\_gme[1,:]} by recording the value \py{1} at the position corresponding to $\AH$, and adding the value \py{10} at the position corresponding to $\TeH$. If Alex collects multiple cards from the pool on his first turn, the value \py{10} is added to all corresponding positions in \py{t\_gme[1,:]} for each collected card. For later turns, similar updates are performed, with the only difference being that the pairs \py{2,20}, \py{3,30}, and \py{4,40} are used instead of \py{1,10} for the second, third, and fourth turns, respectively.

% Importantly, \py{t\_gme[0,:]} is updated after each move to reflect the current state of the game. For cards that are played but not collected with other cards, the corresponding position in \py{t\_gme[0,:]} is set to \py{3}. If a played card is used to collect one or more cards from the pool, then the corresponding positions of the played and collected cards are updated as follows: the hand cards that were played or picked change from \py{1} to \py{0}, and the pool cards that were collected change from \py{3} to \py{0}.


 



% Each card available in \py{t\_inp} have multiple possibilities for it. Each of these possibilities are reflectd in the table below:


% [3,0,0] Card is in pool from the begining of the round and have not been picked yet. 

% [1,0,0] Alex holds this card and has not played it yet 

% [2,0,0] Bob holds this card and has not played it yet 

% [0,i,0] ([0,0,-i]) Alex (Bob) layed this card at round i and has not been picked by either of the players in the subsequent turns yet 

% [0,1,]












% Cards that have already been played in previous rounds are no longer part of the game state.



